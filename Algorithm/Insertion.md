### 삽입 정렬 알고리즘 개념 요약  
손안의 카드를 정렬하는 방법과 유사하다.  
새로운 카드를 기존의 정렬된 카드 사이의 올바른 자리를 찾아 삽입한다.  
새로 삽입될 카드의 수만큼 반복하게 되면 전체 카드가 정렬된다.  
자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교 하여,  
자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘  
매 순서마다 해당 원소를 삽입할 수 있는 위치를 찾아 해당 위치에 넣는다.  

### 삽입 정렬 알고리즘의 구체적인 개념  
삽입 정렬은 두 번째 자료부터 시작하며,  
앞의 자료들과 비교하여 삽입할 위치를 지정한 후  
자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬하는 알고리즘이다.  
즉, 두 번째 자료는 첫 번째 자료, 세 번째 자료는 두 번째와 첫 번째 자료, 네 번째 자료는 세 번째, 두 번째, 첫 번째 자료와 비교한 후 자료가 삽입될 위치를 찾는다.  
자료가 삽입될 위치를 찾았다면 그 위치에 자료를 삽입하기 위해 자료를 한 칸씩 뒤로 이동시킨다.  
처음 Key 값은 두 번째 자료부터 시작한다.  

```
# include <stdio.h>
# define MAX_SIZE 5

void insertion_sort(int list[], int n){
  int i, j, key;

  for(i=1; i<n; i++){
    key = list[i];

    for(j=i-1; j>=0 && list[j]>key; j--){
      list[j+1] = list[j];
    }

    list[j+1] = key;
  }
}

void main(){
  int i;
  int n = MAX_SIZE;
  int list[n] = {8, 5, 6, 2, 4};

  insertion_sort(list, n);

  for(i=0; i<n; i++){
    printf("%d\n", list[i]);
  }
}
```

### 삽입 정렬 알고리즘의 특징  
안정성이 보장되는 정렬 방법이라는 점이 장점  
레코드의 수가 적을 경우 알고리즘 자체가 매우 간단하므로 다른 복잡한 정렬 방법보다 유리할 수 있다.  
대부분 레코드가 이미 정렬되어 있는 경우에 매우 효율적이다.  
  
비교적 많은 레코드들의 이동을 요한다.  
레코드 수가 많고 레코드 크기가 클 경우에 적합하지 않다. 

### 삽입 정렬의 시간복잡도  
최선의 경우  
비교 횟수  
이동 없이 1번의 비교만 이루어진다.  
외부 루프: (n-1)번  
Best T(n) = O(n) 
최악의 경우(입력 자료가 역순일 경우)  
비교 횟수  
외부 루프 안의 각 반복마다 i번의 비교 수행  
외부 루프: (n-1) + (n-2) + … + 2 + 1 = n(n-1)/2 = O(n^2) 
교환 횟수  
외부 루프의 각 단계마다 (i+2)번의 이동 발생  
n(n-1)/2 + 2(n-1) = (n^2+3n-4)/2 = O(n^2)  
Worst T(n) = O(n^2)  

### 참고자료  
https://www.youtube.com/watch?v=fIe7gdgMvMU
https://gmlwjd9405.github.io/2018/05/06/algorithm-insertion-sort.html  

