# 해시

## 01. 해싱

### 개념

- 해시 함수와 해시 테이블을 이용한 키 값의 탐색, 삽입, 제거 기법
- 키 값에 대하여 산술적 연산을 수행해서 테이블의 주소를 계산한 뒤 항목에 접근
- 기존의 탐색 방법은 대부분 키 값을 비교하여 탐색하고자 하는 항목에 접근
- 비유 : 물건을 정리해 놓는 것과 유사 , 물건이 섞여 있는 상태로 두었다가 필요할 때 하나씩 탐색하는 것이 아니라 각 물건마다 고유한 위치에 물건을 보관
- 탐색 시간 : 이론적으로 O(1)

### 해싱에서의 항목 접근 방법

- 기본 아이디어
    
    ![image](https://user-images.githubusercontent.com/76865900/236624205-46615e5b-7a34-4bdc-a71b-4af08d25b0c3.png)
    

- 탐색 키만을 가지고 바로 항목이 저장되어 있는 해시 테이블의 위치를 결정하는 방법
- 해시 테이블의 다른 항목에는 접근할 필요가 없음

### 해싱 예시

![image](https://user-images.githubusercontent.com/76865900/236624260-ce33447f-08bf-44c2-8270-459812bce55e.png)

- 해시 테이블에 (key, value) 쌍으로 저장. 여기서는 key가 탐색 키임
    - 전화번호부의 경우 (key, value) = (성명, 전화번호)
    - 심볼 테이블의 경우 (key, value) = (변수명, 변수의 속성)
    - 사전의 경우 (key, value) = (단어, 단어의 뜻)
    

## 02. 해시 테이블

### 개념

- 탐색 키로부터 해시 함수에 의해 저장 위치를 직접 계산할 수 있는 테이블 구조 (주로 배열)
- (= 키 값 연산에 의해 직접 접근이 가능한 구조 )

### 구성 요소 및 구조

- 해시 주소
    - 해시 함수에 의해 결정된 탐색 키의 저장 주소 (해시 테이블의 인덱스)
- 해시 함수
    - 탐색 키를 입력 받아 해시 주소 생성

- 해시 테이블
    - hash function을 거쳐서 연산된 값(hash 값)을 키(key)값으로 하고, 그에 들어가는 데이터를 Value로 하는 테이블을 생성
    - 이것을 **해시 테이블**이라고 하고**, 버킷 또는 슬롯**이라고 표현
    - m개의 버킷(bucket)으로 구성된 테이블
        - 버킷이란 ?
    - 하나의 버킷에 s개의 슬롯(slot) 가능
        - 하나의 슬롯엔 하나의 항목 저장
        - 서로 다른 두 키의 해시값이 동일할 경우, 동일한 해시 주소에 s개의 항목을 저장할 수 있음
    - key를 통해서 value값을 찾기 때문에 **시간복잡도 O(1)**
        
        ![image](https://user-images.githubusercontent.com/76865900/236624282-d3460cc6-fe66-4c8b-a015-61b5a2247314.png)
        
        ![image](https://user-images.githubusercontent.com/76865900/236624296-50b2c251-683b-4638-83dd-b7149a71c98a.png)

        
- 해시 테이블의 시간 복잡도

| 빅오표기법 | 평균 | 최악 |
| --- | --- | --- |
| 탐색 | O(1) | O(N) |
| 삽입 | O(1) | O(N) |
| 삭제 | O(1) | O(N) |

**평균 O(1)이라는 시간 복잡도는 해시 충돌이 일어나지 않는 이상적인 상황을 고려한 것**

 **해시 충돌이 일어날 수록 시간 복잡도는 최악인 O(N)에 수렴함**

만약 수정된 Chaining방식을 이용하여 해시 충돌된 엔트리들을 Red-Black Tree로 연결한다면 최악의 경우라도 O(logN) (밑은 2)의 시간복잡도를 갖게 됨

**해시 테이블 장단점**

**장점** 

- 해시 충돌이 없는 상태에서 배열, 리스트 같은 선형적인 구조는 물론 트리와 같은 선형적인 구조보다 **빠른 탐색**
- 해시를 사용하기에 해시 값을 알아도 **key를 예측하기 어려움**

**단점**

- **해시 충돌 발생 시 탐색이 시간 복잡도 O(N)에 점점 수렴**함
- 정렬이나 순차적인 메모리 저장이 필요한 경우 적합하지 않음
- 해시 함수의 성능에 따라 해시 테이블 전체 성능이 크게 영향을 받음

### 문제 상황

**실제 해싱 예1 - 슬롯 1개의 경우**

- 실제로는 해시 테이블의 크기가 제한되므로, 존재 가능한 모든 키에 대해 저장 공간을 할당할 수 없음
    - ex) 주민등록번호 13자리 ⇒ 키 공간 10^13 (10조개)
        - 실제 인구는 5,125만명
    - 일반적으로 탐색 키의 공간에 비해 해시 테이블 크기는 작음
    
    ![image](https://user-images.githubusercontent.com/76865900/236624316-9c4d6836-2d96-4e83-8fed-49b7420efd14.png)

    - 해시 테이블 크기 M (그림 예는 31)
    - 해시함수 h(k)= k mod M 의 예
    - 필연적으로 충돌 및 오버플로우가 발생함

**실제 해싱 예2** 

- 알파벳 문자열 키의 해시 함수가 키의 첫 번째 문자의 순서라고 하자
h("array")=0
h("binary")=1
- 입력 데이터 : array, binary, bubble, file, digit, direct, zero, bucket

![image](https://user-images.githubusercontent.com/76865900/236624336-a5418e49-c4a5-4ca4-85ba-6a2e95885500.png)


- 실제 해싱에서 충돌 및 오버플로우는 자주 발생
- 따라서, 시간복잡도는 이상적인 경우의 O(1)보다 좋지
않게 됨

**충돌 (collision)**

- 서로 다른 두 개의 탐색키 k1와 k2에 대하여 h(k1) = h(k2) 인 경우
- k1과 k2는 동의어(synonym)이라 함

**오버플로우 (overflow)**

- 충돌이 버킷에 할당된 슬롯 수보다 많이 발생하는 것
- 오버플로우 해결 방법이 반드시 필요

## 03. 해시 함수

- **좋은 해시 함수의 조건**
    - 계산이 빨라야 함
    - 충돌이 적어야 함
    - 해시 함수 값이 해시 테이블의 주소 영역 내에서 고르게 분포되어야 함
    - 앞의 예2의 경우, 영어 단어가 ‘x’, ‘z’ 등올 시작하는 단어가 적어서 고르게 분포시키기가 어려움

### 해시 함수

- **제산(division) 함수**
    - h(k) = k mod M
    - 해시 테이블의 크기 M은 소수(prime number) 선택
    - M 선택이 매우 중요
    • M = 2x 형태이면, 해시값은 탐색 키의 최하위 x비트에 의해서만 영향을 받음
    뒷부분 x비트 문자들이 같은 탐색 키는 충돌
    • M이 짝수이면, 짝수/홀수 탐색 키는 각각 짝수/홀수 버킷으로 매핑
    • 보통 M은 소수 사용
    • 좋은 M의 예
    –  x, a : 적당히 작은 정수
    –  r : 문자 집합에 대한 기수(radix) 예. ASCII 문자에 대한 기수 r = 27 = 128
    –  M : rx ± a의 약수가 아닌 소수
- **접지(폴딩, foling) 함수**
    - 레코드의 키를 마지막 부분을 제외한 모든 부분의 길이가 동일하게 여러 부분으로 나누고, 이들 부분을 모두 더 하거나 배타적 논리합(XOR)을 취하여, 해시 테이블의 홈 주소로 이용하는 방법으로 두 가지 방법이 사용 된다.
        
        (1) 이동 폴딩(shift Folding)
        
        (2) 경계 폴딩(Boundary Folding)
        

![image](https://user-images.githubusercontent.com/76865900/236624363-a867dc49-3f3a-4c6f-952d-cc2855602bf1.png)


이동폴딩 =>

P1 + P2 + P3 + P4 + P5

= 301 + 230 + 123 + 213 + 30 = 897

897 = 홈주소

경계폴딩 =>

P1 + P2(역) + P3 + P4(역) + P5

= 301 + 032 + 123 + 312 + 30 = 798

798 = 홈주소

- **중간 제곱(mid square) 함수**
    - 탐색 키를 제곱한 다음, k개의 중간 비트를 취해서 해시 주소 생성
    - 제곱값의 중간 비트들은 대개 탐색 키의 모든 문자와 관련
    - 비교적 고르게 분산
- **비트 추출(bit extraction) 함수**
    - 탐색 키를 이진수로 간주하여 임의의 위치의 k개의 비트를 해시 주소로 사용
    - 간단함
    - 탐색 키의 일부 정보만 사용하므로 해시 주소의 집중현상(clustering) 발생 가능
- **숫자 분석(digit analysis) 방법**
    - 키 중에서 편중되지 않는 수들을 해시 테이블의 크기에 적합하게 조합하여 사용
    - (예) 학번 : 1712045 – 앞의 2자리는 편중되어 가급적 사용하지 않고 나머지 수를 조합하여 해시 주소로 사용.

## 04. 해시 충돌

- 서로 다른 탐색 키들이 같은 해시 주소를 갖는 현상
- 이상적 해시 함수를 이용하고 해시 테이블이 충분히 커도 충돌은 필연적으로 발생(생일
역설 참고)
- 충돌에 의해 오버플로우가 발생하면 해시 테이블에 해당 항목 저장 불가능
- **오버플로우**
    - 충돌로 인하여 해당 버킷의 모든 슬롯이 가득 차서 더 이상 항목을 저장할 수 없는 상태
- 오버플로우를 효과적으로 해결하는 방법 반드시 필요
    - 생일 역설 )
        - 23명만 있으면, 2명 이상 생일이 같을 확률이 0.5 이상
        - 테이블 크기가 365, 탐색 키 23개 시,
        적재 비율 = 23/365 = 6.3% 이지만,
        예상 외로 충돌이 일어날 확률은 0.5 이상

### 해결책

### open addresssing

- 비어있는 버킷을 찾아감
- 충돌이 일어난 항목을 해시 테이블의 다른 위치에 저장
- 간단해 보이지만 탐색이 상당히 복잡해 질 수 있음
- 비어있는 버킷을 어떻게 찾아갈까?
    - **Linear probing (선형 조사법)**
    - **Quadratic probing (이차 조사법)**
    - **Dobule hashing (이중 해싱법)**

**선형 조사법** 

- 상황 : 키값을 입력 후  hash function에 의해 얻은 hash value값을 key값으로 해시 테이블에 insert 시도 시 이미 데이터가 있음
- 솔루션 : 다음 버킷이 비어있는지 하나씩 순차적으로 증가 하면서 빈 버킷을 찾음

![image](https://user-images.githubusercontent.com/76865900/236624386-310cccfe-d868-45ec-a651-9ea21cde33ee.png)


- `John Smith`와 `Sandara Dee` 152번으로 동일
- 다음 빈 버킷을 찾아서 153번으로 `Sandara Dee`가 들어간것을 확인함
- `Ted Baker` 도 153 에서 충돌 발생
- 다음 빈 버킷인 154번으로 밀려남
- 최선 :  바로 다음 버킷이 비어있는 경우
- 최악 : 거의 끝까지 모든 버킷이 차있는 경우

### chaining

- 각 버킷을 삽입과 삭제가 용이한 연결 리스트로 구현

![image](https://user-images.githubusercontent.com/76865900/236624406-fac6a869-f09f-4eb4-8b6b-6bfe5ca37bbc.png)


- 해시 충돌이 나면, 해당 버킷(노드)에 chaining 형태로 계속 뒤로 붙임
- `John Smith`와 `Sandara Dee`가 152번에서 충돌
- `John Smith`의 뒤에 체이닝 형태로 `Sandara Dee`가 붙음

## +α :  **Java에서 HashTable, HashMap의 차이**

### HashTable

- `Hashtable`은 동기화를 지원하여, `thread-safe`하다.
    - 멀티스레드 환경에서 사용하기 좋은 자료구조
    - 하지만, HashMap에 비해 느리다. (다른 스레드가 block되고 unblock 되는 대기 시간을 기다리기 때문)
- Hashtable은 key값이나 value값에 `null`이 들어갈 수 없음

### HashMap

- `HashMap`은 동기화를 지원하지 않는다.
    - 단일스레드 환경에서 사용하기 좋은 자료구조
- HashMap의 경우 `thread-safe`하지 않기 때문에 멀티 스레드 환경에서 동시에 객체의 data를 조작하는 경우 data가 깨질 수 있다.
- `HashMap`은 `key` 값이나 `value` 값에 `null`이 들어갈 수 있음

---

**기술 면접 대비**

Q. 해시 테이블(Hash Table)과 시간 복잡도에 대해 설명해주세요.
Q. 해시 맵과 해시 테이블의 차이점에 대해 설명해주세요.
Q. 질문은 무수히 긴 스트링 값이 있을때, 거기서 해당 단어가 있는지 없는지 확인하고자 한다면 어떻게 해야할까?
Q. 직접 해시함수를 하나 정의해보고 분석해보기

---

**출처**

[https://umanking.github.io/2022/06/23/hash-function/](https://umanking.github.io/2022/06/23/hash-function/)

[https://you88.tistory.com/38#:~:text=해시 충돌이 일어날 수록,시간복잡도를 갖게 된다](https://you88.tistory.com/38#:~:text=%ED%95%B4%EC%8B%9C%20%EC%B6%A9%EB%8F%8C%EC%9D%B4%20%EC%9D%BC%EC%96%B4%EB%82%A0%20%EC%88%98%EB%A1%9D,%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84%EB%A5%BC%20%EA%B0%96%EA%B2%8C%20%EB%90%9C%EB%8B%A4).

[https://slenderankle.tistory.com/160](https://slenderankle.tistory.com/160)

[https://velog.io/@kwj2435/자료구조-Hash-HashMap-HashTable](https://velog.io/@kwj2435/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-Hash-HashMap-HashTable)

[https://memostack.tistory.com/233](https://memostack.tistory.com/233)