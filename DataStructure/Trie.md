# 트라이

## 01. 트라이란?

![image](https://user-images.githubusercontent.com/76865900/236624511-82225fb6-9431-4268-8ebd-44380ba408d9.png)


- 문자열의 집합을 표현하는 **'트리 자료구조'**
- 문자열을 저장하고 효율적으로 탐색
- 자동완성 기능, 사전 검색 등 문자열을 탐색하는데 특화되어 있는 자료구조
- 동의어
    - 래딕스 트리(radix tree)
    - 접두사 트리(prefix tree)
    - 탐색 트리(retrieval tree)
    - **트라이**는 re**trie**val tree에서 나온 단어
- 기존 탐색 구조, 이진 검색 트리 (STL set, map) 등의 문제
    - 원소를 찾는데 **O(logN)**의 시간
    - 문자열의 경우 두 문자열을 비교하기 위해서는 문자열의 길이만큼의 시간이 걸리기 때문에
    
    원하는 문자열을 찾기 위해서는 **O(LlogN)**의 시간이 걸리게 됨 (L : 문자열의 길이)
    
    - 트라이는 문자열 특화 자료구조로 이 문제를 해결
    

## 02. 작동 원리 예시

![image](https://user-images.githubusercontent.com/76865900/236624525-d1d166a2-8465-478b-938d-635d76523739.png)


- 구현을 목표하는 트리
- 'abc', 'ab', 'car' 단어들을 'abc'부터 트라이에 저장한다고 가정
    
    ![image](https://user-images.githubusercontent.com/76865900/236624549-84bd2f70-505f-4080-bb44-aecb2cfac00d.png)
    
- 노드 구조
    - **Key**에는 해당 노드의 문자가 들어가고, **Child**에는 자식 노드가 포함
    - **Data**는 문자열이 끝나는 위치를 알려주는 역할을 한다. 예를 들어서 “car”이 “r”에서 끝날 때, “r”을 key로 가지는 노드의 data에 “car”를 입력
    - 해당 노드에서 끝나는 문자열이 없을 경우에는 None으로 그대로 놔둔다.

**abc 삽입 및 탐색 예제**

![image](https://user-images.githubusercontent.com/76865900/236624566-92813ef0-03ab-4a67-8413-587d22ada251.png)

**삽입(abc)**

- 첫 번째 문자는 'a'이다. 초기트라이 자료구조 내에는 아무것도 없으므로 Head의 자식노드에 'a'를 추가해준다.
- 'a'노드에도 현재 자식이 하나도 없으므로, 'a'의 자식노드에 'b'를 추가해준다.
- 'c'도 마찬가지로 'b'의 자식노드로 추가해준다.
- 'abc' 단어가 여기서 끝남을 알리기 위해 현재 노드에 abc라고 표시한다. (Data)

**탐색(abc)**

- Head의 child에 “a”가 속해있음으로, “a”노드로 이동
- “c”노드의 child에 “b”가 속해있음으로 “b”노드로 이동
- “b”노드의 child에 “c”가 속해있음으로 “c”노드로 이동
- 문자열의 탐색이 완료되었고, 현재 노드의 Data값이 존재한다.
- 따라서 “abc”라는 문자열이 존재한다.

**ab 삽입 예제** 

![image](https://user-images.githubusercontent.com/76865900/236624583-68e87a57-91ca-4544-84b1-0225956db473.png)

- 현재 Head의 자식노드로 'a'가 이미 존재
- 'a'노드를 추가하지 않고, 기존에 있는 'a'노드로 이동
- 'b'도 'a'의 자식노드로 이미 존재하므로 'b'노드로 이동
- 'ab' 단어가 여기서 끝이므로 현재 노드에 ab를 표시한다.

**car 삽입 및 ca 탐색 예제** 

![image](https://user-images.githubusercontent.com/76865900/236624600-4def663f-92f5-4867-b74e-1627bf0d2c97.png)

**삽입 (car)**

- Head의 자식노드로 'a'만 존재하고, 'c'는 존재하지 않는다.
- 따라서 'c'를 자식노드로 추가한다.
- 'c'의 자식노드가 없으므로 마찬가지로 'a'를 추가한다.
- 'a'의 자식노드가 없으므로 마찬가지로 'r'을 추가한다.
- 'car' 단어가 여기서 끝이므로 현재 노드에 car를 표시한다.

**탐색 (ca)**

- Head의 child에 “c”가 속해있으므로, “c”노드로 이동
- “c”노드의 child에 “a”가 속해있으므로 “a”노드로 이동
- 문자열의 탐색이 완료되었는데, 현재 노드의 Data값이 없으므로 “ca”라는 문자열은 존재하지 않는다.

**시간 복잡도**

- L : 제일 긴 문자열의 길이, M : 총 문자열들의 수
- 생성 시간 복잡도는 `O(MxL)`
    - 모든 문자열 M개를 넣어야하고, M개에 대해서 트라이에 넣는건 가장 긴 문자열 길이인 L만큼 걸리므로 `O(MxL)`의 시간 복잡도를 가진다. (삽입은 `O(L)`이다.)
- 탐색 시간 복잡도는 **`O(L)`**
    - 트리를 제일 깊게 탐색하는 경우는 가장 긴 문자열 길이인 L까지 깊게 들어가는 것이므로 `O(L)`의 시간 복잡도를 가진다.

**장점**

- 문자열을 빠르게 찾을 수 있음
- 문자열의 추가와 탐색 모두 O(M)만에 가능
    - 문자열을 집합에 추가하는 경우에도 문자열의 길이만큼 노드를 따라가거나, 추가하면 되기 때문

**단점**

- 필요한 메모리의 크기가 너무 크다
- 총메모리는 **O(포인터 크기 * 포인터 배열 개수 * 총노드의 개수)**
    - 문자열이 모두 영소문자로 이루어져 있다고 해도, 자식 노드를 가리키는 26개의 포인터를 저장해야 함
    - 최악의 경우에는 집합에 포함되는 문자열들의 길이의 총합만큼 노드가 필요
    - 1000자리의 문자열이 1000개만 들어온다고 하더라도 100만 개의 노드가 필요하고, 포인터의 크기가 8byte라고 하면 약 200MB의 메모리가 필요하게 됨
- 단점을 해결하기 위해서 보통 **map**이나 **vector**를 이용하여 **필요한 노드만 메모리를 할당하는 방식**들을 이용하는데, 문제에 따라서 메모리 제한이 빡빡한 경우에는 최적화가 꽤나 까다롭다.

---

**풀어보면 좋을 트라이 알고리즘 문제**

- [[백준 5052번] 전화번호 목록](http://boj.kr/5052)
- [[백준 14725번] 개미굴](http://boj.kr/14725)
- [[2020 카카오 코테] 가사 검색](https://school.programmers.co.kr/learn/courses/30/lessons/60060)

---

**출처**

[https://velog.io/@kimdukbae/자료구조-트라이-Trie](https://velog.io/@kimdukbae/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%8A%B8%EB%9D%BC%EC%9D%B4-Trie)

[https://rebro.kr/86](https://rebro.kr/86)

[https://youseop.github.io/2020-11-09-BAEKJOON-14425_문자열집합/](https://youseop.github.io/2020-11-09-BAEKJOON-14425_%EB%AC%B8%EC%9E%90%EC%97%B4%EC%A7%91%ED%95%A9/)